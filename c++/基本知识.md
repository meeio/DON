
# C++的多态
C++ 的多态体现在「重载」和「重写」。

## 编译时多态
一个函数存在不同的参数列表，即函数的「重载」。

## 运行时多态 -- 虚函数
虚函数是C++标准所制定的，实现虚函数时，各大编译器都采用「虚函数表」。

「虚函数表」是保存类内虚函数地址的表格，一个类，共享同一个虚函数表。
「虚函数表指针」是指向虚函表的指针，其由类的实例持有。

### 构造函数和析构函数可以是虚函数吗？

{% hint style="info" %}
参考内容：Effective C++, Item7 
{% endhint %}

构造函数不能是虚函数，因为在构造函数执行前，类的虚函数表指针是空的。
析构函数最好是虚函数，因为一个父类指针可能指向子类对象，在这种情况下，只有构造函数为虚函数，才能保证对子类进行析构，避免内存泄漏。

当存在一个函数为虚函数时，需要将析构函数生命为虚函数以防止潜在的内存泄露。
但不存在虚函数时，则不需要将析构函数生命为虚函数，可以节省虚函数指针与虚函数表的额外开销。


# 静态链接(库)和动态链接(库)

{% hint style="info" %}
参考内容：https://zhuanlan.zhihu.com/p/83716863
{% endhint %}

在一个程序的编译过程中，分为以下几个步骤：预处理，编译，汇编，链接。其中链接的库分为两种「静态链接库:」和「动态链接库」，前者对应`.a`/`.lib`， 后者对应`.so`/`.dll`。

对于「静态链接库」而言在链接阶段，会将汇编生成的「目标文件.o」与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。
- 静态链接库对函数库的链接是放在编译时期完成的。程序在运行时与函数库就没有了任何的联系。
- 它可能比较浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。
- 静态库对程序的更新和发布也会带来麻烦。如果静态库更新了，所有使用它的应用程序都需要重新编译、部署、发布给用户。

「动态链接库」在程序编译时并不会被连接到目标代码中，而是在程序运行时才被载入。
- 不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，可以实现进程之间的资源共享。（因此动态库也称为共享库）规避了空间浪费问题。
- 动态库在程序运行时才被载入，也解决了静态库对程序的更新、部署和发布带来的麻烦。用户只需要更新动态库即可将一些程序升级变得简单，增量更新。

# Static关键字

- 静态成员变量（面向对象）
- 静态成员函数（面向对象）
- 静态全局变量（面向过程）
- 静态局部变量（面向过程）
- 静态函数（面向过程）

# 类型转换

## static_cast

static_cast可以执行基本类型的转换以及相关类型的转换，其是在编译时期完成的，不提供安全检查。基于这个特性，可以利用其先将指针转换void类型，随后在转换为明确类型。


## dynamic_cast

与static_cast，dynamic_cast会执行相关类型的转换，但会在运行时检查类型转换是否合法，具有一定的安全性。由于运行时的检查，所以会额外消耗一些性能。

转换有连个方向：Base to Derived (B2D) 或者 D2B。
D2B 比较简单，唯一存在问题的就是「菱形继承」。
B2D 比较复杂，首先这些类需要满足多态，如果转换失败，则会返回空的引用或者抛出异常（对指针来说）。

## const_cast

常量指针被转换成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然引用原来的对象。

## reinterpret_cast
非常激进的指针类型转换，在编译期完成，可以转换任何类型的指针，所以极不安全。非极端情况不要使用。

# 引用

## 左值引用
常规引用，一般表示对象的身份。

## 右值引用
右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。

右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：

消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
能够更简洁明确地定义泛型函数。

# new 与 malloc 的区别

**最大的区别：**new在申请空间的时候会调用构造函数，malloc不会调用。在对象消失时会调用析构函数。

new会先调operator new函数，申请足够的内存（底层也是malloc实现），然后调用类的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数来释放内存（底层是通过free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构函数

**申请失败返回：**new在申请空间失败后返回的是错误码bad_alloc，malloc在申请空间失败后会返回NULL。

**属性上：**new/delete是C++关键字需要编译器支持，maollc是库函数，需要添加头文件。

**参数：**new在申请内存分配时不需要指定内存块大小，编译器会更具类型计算出大小，malloc需要显示的指定所需内存的大小。

**成功返回类型：**new操作符申请内存成功时，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，因此new是类型安全性操作符。malloc申请内存成功则返回void*，需要强制类型转换为我们所需的类型。

# const

**修饰变量**，说明该变量不可以被改变；

**修饰指针**，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；

**修饰引用**，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；

**修饰成员函数**，说明该成员函数内不能修改成员变量。

# volatile 

{% hint style="info" %}
参考内容：https://stackoverflow.com/questions/4437527/why-do-we-use-volatile-keyword
{% endhint %}

关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。

