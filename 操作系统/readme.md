## ⭕ 线程与进程

### 区别:

* 进程是资源分配的基本单位；线程是程序执行的基本单位。
* 进程拥有自己的资源空间，启动一个进程，系统就会为它分配地址空间；而线程与CPU源分配无关，多线程共享同一进程内的资源，使用相同的地址空间。
* 一个进程可以包含若干个线程。

### 对比

|      | 多进程                                               | 多线程                                              |
|-------------|-----------------------------------------------------|----------------------------------------------------|
| 数据共享、同步 | 数据共享复杂，需要用 IPC；数据是分开的，同步简单             | 因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂 |
| 内存、CPU    | 占用内存多，切换复杂，CPU 利用率低                        | 占用内存少，切换简单，CPU 利用率高                       |
| 创建销毁、切换 | 创建销毁、切换复杂，速度慢                               | 创建销毁、切换简单，速度很快                             | 
| 编程、调试    | 编程简单，调试简单                                     | 编程复杂，调试复杂                                    |
| 可靠性       | 进程间不会互相影响                                     | 一个线程挂掉将导致整个进程挂掉                          | 
| 分布式       | 适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单 | 适应于多核分布式                                     |

### 优劣

|  | 多进程                          | 多线程                          |
|-----|--------------------------------|--------------------------------|
| 优点 | 编程、调试简单，可靠性较高          | 创建、销毁、切换速度快，内存、资源占用小 |
| 缺点 | 创建、销毁、切换速度慢，内存、资源占用大 | 编程、调试复杂，可靠性较差          |

### 选择

* 需要频繁创建销毁的优先用线程
* 需要进行大量计算的优先使用线程
* 强相关的处理用线程，弱相关的处理用进程
* 可能要扩展到多机分布的用进程，多核分布的用线程

> 多进程与多线程间的对比、优劣与选择来自：[多线程还是多进程的选择及区别](https://blog.csdn.net/lishenglong666/article/details/8557215)

## ⭕ 进程通讯(IPC)

* **管道**。管道的通知机制类似于缓存，就像一个进程把数据放在某个缓存区域，然后等着另外一个进程去拿（FIFO），并且是管道是单向传输的。其中分为两种管道：
  + 有名管道：适合于无亲缘关系进程间的通信。
  + 匿名管道：适合于有亲缘关系进程间的通信。

	
	管道通讯的优缺点

  + 优点：比较简单。
  + 缺点：会阻塞进程，这种通信方式效率低下，且缓存区大小有限。

* **消息队列**。一系列保存在内核中消息的链表。

用户进程可以向消息队列添加消息，也可以向消息队列读取消息。
消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，

  + 优点：接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。把进程的数据放在某个内存之后就马上让进程返回，不阻塞。
  + 缺点：如果进程发送的数据占的内存比较大，并且两个进程之间的通信特别频繁的话，需要花很多时间来读内存。

* **共享内存**。共享内存可以解决拷贝所消耗的时间。

	系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了。
	**使用信号量规避冲突。**

  + **信号量**。信号量（semaphore）是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。

* **套接字（Socket）**。可用于不同计算机间的进程通信
  + 优点：
    - 传输数据为字节级，传输数据可自定义，数据量小效率高		
    - 可以加密,数据安全性强
  + 缺点：需对传输的数据进行解析。

> 参考计算机网络内容

## 线程间的通讯方式
线程间主要通过锁进行同步，主要的锁有以下：

- **互斥量（mutex）**：互斥锁，得到锁的线程才可以进入临界区执行代码。当线程抢互斥锁失败的时候，线程会陷入休眠。优点就是节省CPU资源，缺点就是休眠唤醒会消耗一点时间。依据同一线程是否能多次加锁，把互斥量又分为如下两类：
	- 可重入锁（reentrant mutex）：同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁。可以一定程度避免死锁。
	- 不可重入锁（non-reentrant mutex）。

- **条件变量（condition variable）**：条件变量不是锁，它解决的问题不是「互斥」，而是「等待」。例如「生产者消费者」模式中，直到队列中有内容了，消费者才加锁。

- **读写锁**： 是针对读多写少的优化：

	- 当读写锁被加了「写锁」时，其他线程对该锁加读锁或者写锁都会阻塞。 
	- 当读写锁被加了「读锁」时，其他线程对该锁加写锁会阻塞，加读锁会成功。

- **自旋锁（spinlock）**：不同于互斥变量，当抢锁失败时会「进入休眠」，自旋锁是一个「busy waiting」的过程，其不进入休眠。其减少了不必要的上下文切换，执行速度快，但是浪费CPU。

### 死锁

#### 产生条件

* **互斥**：在一段时间内某资源只由一个线程占用。
* **请求和保持**：指线程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
* **不剥夺**：指线程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
* **环路**：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。

#### 预防

* **破坏互斥条件**：使资源同时访问而非互斥使用，就没有进程会阻塞在资源上，从而不发生死锁。只读数据文件可采用这种办法管理。
* **破坏请求和保持条件**：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。
* **破坏不剥夺条件**：通过设置一个”最长占用时间“来强迫线程归还钥匙。
* **破坏环路等待条件**： 强制规定任何线程取钥匙都需要按指定顺序。