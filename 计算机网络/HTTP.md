

# HTTP 概述

HTTP 是一个基于 `TCP/IP` 通信协议来传递数据的协议，传输的数据类型为HTML 文件、图片文件、查询结果等。
HTTP 是一种「请求/响应」（「Request/Response」）模式的协议。
浏览器作为 HTTP 客户端通过 `URL` 向 HTTP 服务端发送「请求」，服务器向浏览器返回「相应」。

# HTTP 的长连接与短连接

`HTTP1.0` 基于 「短连接」：浏览器和服务器每进行一次操作，就建立一次 TCP 连接，在任务结束就中断连接。

`HTTP1.1` 引入 「长连接」：由于 TCP 建立连接代价大，所以在 `HTTP1.1` 中引入「长连接」，在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。

在 HTTP 相应头部的 `Connection` 键值对可以控制链接状态。

`HTTP2.0` 引入多路复用解决了线头阻塞问题。「线头阻塞」是标识请求顺序可能会出现客户端收到响应和请求对不上的情况，所以只能等一个请求处理完才能处理下一个。


# HTTP 无状态

HTTP无状态协议，因为它的每个请求都是完全独立的，对交互性场景上下文没有记忆能力。

> 无状态是不准确的说法，`HTTP/1.1` 中有一个 `Expect: 100-Continue` 的功能，参考 POST 请求的相应。

## Cookie 与Session  Token

「Cookie」是服务器发送到浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。

「Session」代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性信息。在 Session 中确认用户身份会用到 Cookie，即 `Session_Id`。

|          | Cookie             | Session                             |
| -------- | ------------------ | ----------------------------------- |
| 存储位置 | 客户端             | 服务器                              |
| 存取方式 | 只保存字符串       | 保存各种类型数据                    |
| 有效期   | 可设置为长时间保持 | 保存各种类型数据                    |
| 存取方式 | 只保存字符串       | 客户端关闭或者 Session 超时都会失效 |


## Token

Session 的存储是需要空间的，频繁的查询数据库给服务器造成很大的压力。
在这种情况下，「Token」应用而生。

服务端会根据传过来的唯一标识 `userId`，运用一些算法，并加上密钥，生成一个 Token，然后通过 `BASE64` 编码之后将这个 Token 返回给客户端，客户端将 Token 保存起来（可以通过数据库或文件形式保存本地）。下次请求时，客户端只需要带上 Token，服务器收到请求后，会用相同的算法和密钥去验证Token。

使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：

1. 用户通过用户名和密码发送请求。
2. 程序验证。
3. 程序返回一个签名的 token 给客户端。
4. 客户端储存 token,并且每次用于每次发送请求。
5. 服务端验证 token 并返回数据。

# HTTPS

HTTP 在网络上是明文传输，所以引入了 `HTTPS` （S for Secure）。
在实现时，其实是 HTTP 加上了 `SSL` （也称作 `TSL`） 层。
主要有三种方法保证安全。

## 对称加密

对称加密只有一个加密钥匙，过程为：

1. 服务器发送「公钥」给客户端。
2. 客户端利用「公钥」加密，加密后传输到服务器。
3. 服务器利用「公钥」解密。
   
其问题在于第一次传输时，可能会被第三方获取「公钥」，从而时后续失效。

## 非对称加密

非对称加密服务器与客户端都拥有一对「私钥」与「公钥」：

1. 服务器发送「s-公钥」给客户端。
2. 客户端利用「s-公钥」加密「c-公钥」，随后传输到服务器。
3. 服务器利用「s-私钥」解密，得到「c-公钥」。
4. 服务器利用「c-公钥」对后续内容进行加密，随后再发送到服务器。
   
「公钥」都是明文传输，即使被截取，由于没有「私钥」无法解密。
但任然存在问题，第三方可能截取两边的「公钥」伪造成 服务器/客户端 向另一方通讯。

## 证书

引入权威的证书颁发机构（CA）来解决上述问题。
证书颁发机构自己也有一对「公钥」与「私钥」。
各大浏览器和操作系统已经维护了所有权威证书机构的名称和「公钥」。

1. 服务器发送「公钥」给 CA。
2. CA利用「A-私钥」加密收到的「s-公钥」以及基于服务器网址信息生成的「证书签名」，将加密后的信息（即「证书」）返回给服务器。
3. 服务器将「证书」发送给客户端。
4. 客户端也向 CA 利用同样的信息申请「证书签名」，若其与收到的「证书签名」一致，则通过认证，使用得到的「公钥」进行对称加密。