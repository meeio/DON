### 同步 异步 阻塞 非阻塞

作者：Yi Lu
链接：https://www.zhihu.com/question/19732473/answer/20851256
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

阻塞”与"非阻塞"与"同步"与“异步"不能简单的从字面理解，提供一个从分布式系统角度的回答。1.同步与异步同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由*调用者*主动等待这个*调用*的结果。而异步则是相反，*调用*在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。典型的异步编程模型比如Node.js举个通俗的例子：你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。2. 阻塞与非阻塞阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。还是上面的例子，你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。如果是关心阻塞 IO/ 异步 IO, 参考  Unix Network Programming View Book


### I\O 多路复用 select 与 epoll

> ref: https://zhuanlan.zhihu.com/p/64138532

#### Select

Select 通过文件描述符 `fd` 列表来储存要监听的 socket，并且把主线程添加到这些 socket 的「等待队列」中。
`fd` 列表会被拷贝至内核，当其中的socket接收到数据时，会触发中断程序，内核接过CPU使用，将主线程从每个socket的「等待队列」中删除，并加入到「工作列表」中。
主线程被激活后，开始遍历 `fd` 列表寻找就绪的 socket。

Select 的缺点在于需要大量的拷贝，而且需要 O(n) 的时间遍历 `fd` 列表进行「等待队列」的相关操作，以及线程激活后的就绪 socket 查询。

#### Epoll

由于 Select 是直接与主线程进行交互的，所以这种设计也是不可避免，可以引入中间方来解决 Select 存在的问题，这就是 Epoll的主要思想。

Epoll 本身就是一个系统管理的文件，其句柄由 `epoll_create` 创建，此时主线程会被添加到 Epoll 的等待序列。
Epool 调用 `epoll_ctl` 指定需要监听的 Socket，Epoll 会遍历这些 Sokcet为其添加回调函数，当 Socket 接收到数据触发中断程序时，会通过回调函数将自身的 `fd` 添加到 Epoll 维护的就「绪队列中」。
`epoll_wait` 的工作实际上就是在这个就绪链表中查看有没有就绪的 `fd`，如果有的话就通知 Epoll 的等待进程。

Epoll 克服了 Select 的缺点， 对于主线程来说只需要 O(1) 的时间就可以定位到激活的 Socket。 


